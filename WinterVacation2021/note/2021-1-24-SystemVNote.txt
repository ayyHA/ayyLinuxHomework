System V IPC:
	System V IPC由System V UNIX提供，与POSIX兼容
	由三种IPC机制组成：消息队列、共享存储、信号量

	-	消息队列：允许进程发送/接收不同大小的数据。通信进程通过唯一的消息队列标识ID相互连接，数据通过包的形式传送至消息队列。按FIFO顺序进行
	-	共享存储：允许多进程访问存储区中同一数据区。通信进程通过唯一标识的共享存储连接在一起，像正常存储访问来访问这块共享的存储区，从而实现数据交换
	-	信号量：信号量用以告知某个事件是否发生。进程可打开/关闭一组信号量集合的标志。通信进程与同一信号量集合标识相连，进程们均可读/改信号量集合的标志。注：信号本身无数据传送，是用来控制对某种资源的访问，以实现进程同步。

	关键字：
	数据类型：key_t 实则为 long int
	作用：用来获得某一IPC资源的唯一标识ID，之后便没有作用了！但这个标识ID是进程通信的关键
	取值可分为：
		-	IPC_PRIVATE：即0，意为：总是创建一个新的IPC资源。即进程私有的IPC资源，一般用于亲缘型进程通话，因子进程可获得父进程的IPC资源，实现父子通话，或子父子形式的CSC
		-	非0正整数：即整常数

	通信进程通过访问同一个IPC资源以实现协同工作，则它们需要使用相同的关键字。但因为关键字是long int 类型，不方便记忆也容易冲突，因此有下面函数的出现
	
	key_t ftok(const char* path, int id)

	这个函数即通过一个已存在的文件名和自定义的参数id来返回一个唯一的关键字。注：参数id只取低8位。若id为0，ftok()行为不确定

	不难看出，通过ftok的方式，可以根据文件名和id来获得唯一的关键字，则应使用了文件的inode号来确定关键字的一部分。因此，若是文件删除后又再创同名文件，其关键字亦会因为inode号的变化而变化
	且通过如此用法，使得对关键字key的使用如打开一个文件一般，通过open文件，获得文件描述符；通过xxxget使用的关键字参数，获得对应IPC资源的唯一标识ID。

	标识：
	每一个独立的消息队列、信号量集合、共享存储段都由一个唯一的正整数所标识！
	由上所述，关键字像是文件名，可以打开/创建对应的IPC资源，而标识ID就像文件描述符，可以控制、操作IPC资源的行为。

	注：关键字的唯一性体现在所有的IPC资源上；
		标识ID的唯一性体现在一种IPC资源上，即 (key_t)1234 一旦用了，就不许再次被使用，除非你想通过它来进行进程间的通信活动。而若是通过关键字get了一个如消息队列的标识ID：2，也可以通过另一个关键字get一个如共享存储的标识ID：2，这两个2是不冲突的！
	
	IPC资源描述结构与成员ipc_perm：
	每一个IPC资源被创建时，内核会在系统内部创建它的标识和一个类型为xxxid_ds的数据结构与之相连。xxxid_ds中有个ipc_perm类型的成员存储了访问权限、属主及创建者等的信息。
	xxxid_ds称为IPC资源描述

	xxxid_ds这个结构体里面有个ipc_perm类型的成员xxx_perm，就是存储了上述所说的信息的成员。
	
	ipcs、ipcrm命令：
		ipcs：ipc search，即查看本机上所有的IPC资源，可通过-q查看消息队列、-m查看共享存储、-s查看信号量
		ipcrm：ipc remove，即移除某一个特定的IPC资源，其使用方式为：ipcrm -q 1 即移除消息队列标号ID为1的IPC资源。

	
	以下介绍一种IPC资源的使用方式，另外两种大同小异：
		消息队列 message queue：
	消息队列是半双工的通信通道，是由离散的消息组成队列，消息的结构可以不一样。是先进先出的结构、也可以有优先级。
	多个进程可以通过访问一个公共的消息队列来交换信息。
	
	而多个进程访问一个它们之间共有的消息队列，是利用该消息队列的标识ID，这个标识ID是通过关键字来获得的，而且在所有的消息队列的IPC资源内，是唯一的标识ID。

	+++++++++++++++++++msgget()++++++++++++++++++++	
	int msgget(key_t key,int flags);
	此函数通过给入的关键字和标志位(创建标志和访问标志)创建或返回(已存在)一个消息队列的标识ID
	访问标志与文件的访问标志一样，只不过没有了执行标志位，因为不具备任何意义。故实质只有110(rw-)
	创建标志有两个：IPC_CREAT和IPC_EXCL。IPC_CREAT表示：若不存在关键字所指向的IPC资源，则创建一个并返回对应的标识ID；若存在，则返回已存在的标识ID；IPC_EXCL表示：若存在与key相连的IPC资源，则报错

	因此要创建一个新的消息队列并获得其标识ID，可以通过
		I、从关键字出发，用IPC_PRIVATE来建立进程私有的消息队列资源，并获得对应的msgid;
		II、从标志位出发，用IPC_CREAT|IPC_EXCL来获得新的IPC资源的标识ID
	调用成功，返回对应的消息队列标识ID
	注：若标志位为0，则表示查询已存在的消息队列ID，故无需任何访问标志，也不需创建标志。


	+++++++++++++++++++msgctl()++++++++++++++++++++
	int msgctl(int msqid,int cmd,struct msqid_ds *buf);
	msqid表示操作的消息队列的标识ID，cmd表示所需要执行的控制操作，buf是msqid_ds消息队列资源描述的指针对象，用于设置或查询消息队列的具体情况
	常用的操作有以下几种(即cmd参数取值)：
		- IPC_STAT：复制内核的msqid_ds对象至buf给用户
		- IPC_SET：设置内核的msqid_ds对象。可设置ipc_perm数据结构成员和msg_qbytes来修改队列中所能存放的最大字节数
		- IPC_RMID：即remove id。移除msqid指定的消息队列
	调用成功，返回0；否则返回-1并置errno
	

	++++++++++++++++msgp消息缓冲区+++++++++++++++++
	消息缓冲区是一个结构，系统要求第一个参数消息类型必须是long int类型且值>0外，便不做其他要求，即后面的消息正文的成员可以自行定义！如，以下便是消息缓冲区的一种表示方法：
	struct msgbuf{
		long int mtype;		// 消息类型，值必须大于0
		char mtext[BUFSIZ]; // BUFSIZ是系统的一个参数，是8192B，16384B是系统默认的msg_qbytes值
	};


	+++++++++++++++++++msgsnd()++++++++++++++++++++
	int msgsnd(int msqid,const void* msgp,size_t msgsz,int msgflg);
	msqid表示存储发送信息的队列ID；msgp是指向用户消息缓冲区的指针；msgsz，即消息缓冲区中的消息正文的字节数；msgflg针对的是发送的消息的阻塞情况。
	msgsnd()向消息队列msqid发送一条消息，这条消息是存放在消息缓冲区msgp中的，消息正文部分的大小是msgsz，采取的阻塞方式是msgflg.

	以下情况发生阻塞：
	- 消息队列中的字节数msg_cbytes已达上限
	- 系统中所有消息队列的消息总数已达到系统的限制值

	若 msgflg 设置为 IPC_NOWAIT ,发生阻塞时，消息则不被发送，置errno为EAGAIN后立即返回；
	若 msgflg 设置为 0，发生阻塞时，会被阻塞，直至：
		- 导致阻塞的条件不再存在，此时，消息被发送，调用成功返回；
		- 消息队列标识ID被删除，置errno为EIDRM并返回-1；
		- 调用进程收到中断信号，消息不被发送，置errno为EINTR并返回-1；

	+++++++++++++++++++msgrcv()++++++++++++++++++++
	ssize_t msgrcv(int msqid,void* msgp,size_t msgsz,long int msgtyp,int msgflg);
	msqid表示从哪一个消息队列中接受消息；msgp是接受传来的消息的消息缓冲区指针；msgsz是消息缓冲区的消息正文的字节数；msgtyp是要接收的消息类型；msgflg针对的是接受消息存在的阻塞情况。
	msgrcv表示从msqid这个消息队列中读取消息，读取的消息存放在msgp中，消息正文的大小为msgsz，读取的消息类型是msgtyp，对读取消息时的阻塞方式的解决情况是msgflg。
	
	msgtyp所指明的消息类型存在以下几种情况：
	- msgtyp = 0 ，接收队列里的首个消息。即按消息的发送顺序来进行接收；
	- msgtyp > 0 ，即指定特定的接收类型msgtyp的消息，也是按该类型消息的发送顺序来进行接收；
	- msgtyp < 0 ，接收类型小于等于|msgtyp|的首个最低类型的消息。用于优先接收消息。

	以下情况发生阻塞：
	- 接收的消息不在消息队列时

	msgflg取值：
	- MSG_NOERROR，指明当接收的消息的正文大于msgsz时，所采取的策略是截断多出的部分还是置errno为E2BIG;
	- IPC_NOWAIT，指明当消息阻塞时，立即以失败返回，置errno为ENOMSG；

	若没有设置IPC_NOWAIT且发生阻塞时，直至：
	- 所要读的消息已被放置入队列中，此时，消息被接收，调用成功返回；
	- 消息队列标识ID被删除，置errno为EIDRM并返回-1;
	- 调用进程收到中断信号，消息不予接收，置errno为EINTR并返回-1；
